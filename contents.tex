% http://wiki.eclipse.org/Bug_Reporting_FAQ
%   when a test pass comes up a component owner can build a query that searched for resolved bugs
%   After testing that the fix worked a resolved bug can be transitioned to verified, directly to closed, or in fact, reopened. 
%   By searching for bugs with a Status of verified and a resolution of fixed developers can come up with release notes.
%   Severity is assigned by a user and describes the level of impact the bug is having on them. Priority is assigned by the developer and describes the importance a developer places on fixing the bug.

\begin{section}{Introduction}

Bug repositories (or bug tracking systems) have since a long time been used in software projects to support coordination among stakeholders. Such systems record discussion and progress of software evolution activities, such as corrective, perfective, and ... changes \cite{Antoniol2008}. Hence, bug repositories are an opportunity to researchers who intend to investigate issues related to the quality of the product and of the process of a software development team, which can give insights about the nature of software development itself.

The information contained in bug repositories have been used in order to predict fault-proneness, to unveil developers' roles from data, to characterize transfer of work in software projects, and so on. Also, it has been used to investigate beliefs in software engineering related to software quality, such as the impact of developer turnover and of collective ownership on the occurrence of bugs.

However, mining bug repositories has its own risks. Previous research has identified problems of missing data (e.g., rationale, traceability links between reported bug fixes and source code changes) and inaccurate data (e.g., misclassification of bugs) \cite{Aranda2009,Bird2009,Nguyen2010,Ayari2007}.

\TODO why the VERIFIED status is so important?

In summary, for researchers who intend to use data from bug tracking systems, it is not sufficient to understand the data fields in a bug report the way they are documented in the system's documentation. The research should also investigate whether the data fields are used often, whether they are used accordingly to the documentation, and even if the data fields are used consistently across the developers.

In this paper, we investigate the status of a bug, a data field present in most bug tracking systems that reports the progress of the bug solving activity. In particular, we focus on the activity of verification of a fix. We are interested in answering the following exploratory research questions:

\begin{itemize}
	\item What activity is actually performed when a bug fix is marked as verified?
	\item When is the verification performed (i.e., just after the fix, or is there a specific period for the verification of fixed bugs?)
	\item How is the distribution of verification across developers?
	\item Is there a dedicated team for QA?
\end{itemize}

For research question xx, qualitative of a small sample. 
For research question xx, all bugs were considered.

\end{section}

\begin{section}{Background}
\end{section}

  \begin{subsection}{Bug Tracking Systems}
Bug workflow. Bugzilla. \cite{Bird2009}

% Reposit ́orios de bugs. Arquivam relat ́orios de defeitos e solicitac ̧ ̃oes de mudan ̧ca. Tais reposito ́rios ajudam os desenvolvedores a registrar, discutir e acompanhar a situa ̧ca ̃o de cada solicita ̧c ̃ao, desde a atribui ̧ca ̃o de uma solicita ̧ca ̃o a um desenvolvedor at ́e a verifica ̧c ̃ao da corre ̧c ̃ao ou melhoria. Exemplos incluem o Bugzilla, o Trac e o Jira.

Bug tracking systems allow users and developers of a software system to manage a list of bugs for the system. Usually, users and developers can report bugs, along with information such as steps to reproduce the bug, its severity, the operating system used etc. Developers choose bugs to fix and can report on the progress of the bug fixing activities, ask for clarification etc.

One important feature of a bug that is recorded on bug tracking systems is its status. The status records the progress of the bug fixing activity, and, as such, provides data to software engineering studies. Figure \ref{fig:bugzilla} shows each status that can be recorded in Bugzilla, a popular bug tracking system, along with typical transitions between status values, i.e., the workflow. Other systems present comparable status values and transitions.

\begin{figure}[ht]
	\centering
		\includegraphics[scale=0.4]{bugzilla.png}
	\caption{Workflow for Bugzilla. Source: \url{http://www.bugzilla.org/docs/2.18/html/lifecycle.html}.}
	\label{fig:bugzilla}
\end{figure}

In the simplest cases, a bug is created and receive the status \texttt{UNCONFIRMED} (if it was created by a regular user) or \texttt{NEW} (if it was created by a developer). Next, it is assigned to a developer, and then it is resolved, possibly by fixing it with a patch on the source code. The solution is then verified by someone in the quality assurance team. If it passes the quality requirements, it is closed and the patch is added to the next release. If it doesn’t pass the quality requirements or if the solution only partially fixes the problem, the bug is reopened.


\end{subsection}

\begin{section}{Method}
	
\end{section}

\begin{section}{Data Extraction}

	We have had access to Eclipse Bugzilla database from October, 2001 to June, 2010, in MySQL format. The data was made available as part of the Mining Software Repositories 2011 Challenge\footnote{\url{http://www.msrconf.org/msr-challenge.html}}.

	The database includes data from 155 Eclipse subprojects. However, we have discarded subprojects in which no bug was ever reopened, and subprojects with less than 50 reported bugs.

	For the remaining 34 subprojects, we have selected only bugs that were verified until December 2009. The rationale is that if, within six months, a verified bug was not reopened, it probably will not be reopened after that and it is, thus, fully fixed.

\begin{subsection}{The Eclipse Project}
	History. \\
	Recommendations about Bugzilla usage. Four-eyes principle.

	The Eclipse Project was created in 2001 by IBM and released into open source in 2004\footnote{\url{http://www.eclipse.org/org/}}, with focus on the creation of a extensible platform that supports the software development lifecycle. Today, it is maintained by its open source community, as well as by IBM employees and people from other organizations.

	The Eclipse Project consists of many subprojects, including the Platform project and dozens of plugins. Although each subproject is maintained by a distinct team and is relatively autonomous, all of them should follow a general, documented process. 

	All subprojects use Bugzilla for bug reporting, and there are clear rules regarding the process of change in the software\footnote{\url{http://wiki.eclipse.org/Development_Resources/HOWTO/Bugzilla_Use}}. Here is an excerpt of a document in the Eclipse web site that explains the bug fixing process\footnote{\url{http://wiki.eclipse.org/Bug_Reporting_FAQ}} (emphasis added):

	\begin{quote}
	When a new bug is entered it begins life with a Status of either \textbf{Unconfirmed} for normal users or \textbf{New} for users with commit privileges. The bug is typically assigned to the component owner. The component owner will usually use a query of Status = Unconfirmed or New and Assigned to = me to browse what is essentially the component's inbox. She or he will assign bug reports to developers. Email will be generated to the developer (this part is configurable). (Note that the act of reassigning a bug to somebody changes its status to New). The developer may change unconfirmed bugs to new.

	The assigned developer will “accept” the bug which will change its status to \textbf{Assigned}. After working on the bug the developer will mark the bug as \textbf{Resolved} and will select a resolution (Fixed, Invalid, Wontfix, Worksforme).

	Once a bug is resolved there are still a few states it can transition to. How you choose to use these states will be up to individual teams. In our example, when a test pass comes up a component owner can build a query that searched for resolved bugs. After testing that the fix worked a resolved bug can be transitioned to \textbf{verified}, directly to \textbf{closed}, or in fact, \textbf{reopened}. By searching for bugs with a Status of verified and a resolution of fixed developers can come up with release notes. A verified/fixed bug can then be transitioned to closed. And yes, closed bugs can be reopened if need be. As an added bonus other bug status can be transitioned through verified to closed as well. This gives developers the opportunity to test worksforme claims.
	\end{quote}

	There’s also a recommendation to follow the four eyes principle in the verification process (emphasis added):

	\begin{quote}
	When a developer fixes the bug, the status is set to RESOLVED - FIXED, and it is assigned to another developer on the team to verify. \textbf{It is important that the verifier be a different person than the fixer} because the fixer is too close to the code and thus may not be as diligent at testing the corner cases.
	\end{quote}

	Finally, there are additional guidelines regarding the workflow:

	\begin{quote}
		\begin{itemize}
	\item All bugs should be verified before the next integration build.

	\item When a committer verifies a fix, the status is changed to VERIFIED.

	\item When the project does a major release, the VERIFIED bugs are changed to CLOSED.
		\end{itemize}
	\end{quote}
\end{subsection}

\begin{subsection}{The Netbeans Project}
	History. \\
	Recommendations for developers.
\end{subsection}

\end{section}

\begin{section}{Data Sampling}
	Scripts to classify interesting cases.
	Random sampling stratified by case.
	
\end{section}

\begin{section}{Analysis}
	grounded theory-style.
	
\end{section}

\begin{section}{Conclusion}
	
\end{section}

\begin{section}{Experimental Setup}

\begin{verbatim}
Data extraction
Data processing: 
- filtering (bugs up to december 20xx)
- classification script
Sampling:
- random sampling (for coding)
- entire data set
Analysis:
- grounded theory (open coding)
- latent Dirichlet allocation
- descriptive statistics
\end{verbatim}

\end{section}

\begin{section}{Results}

	O que quer dizer “a solução de um bug foi verificada”?

	Como já foi comentado anteriormente, o Bugzilla permite que os relatórios de bugs sejam marcados como RESOLVED (resolvido) e, depois, como VERIFIED (verificado). Mas afinal, o que significa verificar a solução de um bug? Que atividades ou checagens foram realizadas antes de se marcar o bug como VERIFIED?

	A documentação do Bugzilla tem algo a dizer sobre isso o status VERIFIED:

	“QA [quality assurance team] has looked at the bug and the resolution and agrees that the appropriate resolution has been taken.”

	Essa definição sugere que a verificação deve ser feita por uma equipe especializada em controle de qualidade. Além disso, o verificador deve concordar que a resolução é apropriada. A definição do Bugzilla para por aí, mas eu consigo imaginar alguns critérios para considerar uma resolução apropriada:

	O bug não se manifesta após a aplicação da solução.
	A solução não gera novos bugs.
	O código da solução segue as convenções de codificação e políticas do projeto.
	A solução possui uma boa relação custo-benefício — isto é, ou não existem soluções melhores ou a solução é um paliativo por conta da alta complexidade de uma solução melhor.
	Minha expectativa, portanto, é que, antes de o bug ser marcado como VERIFICADO, ele passe pelas seguintes atividades:

	Aplicação do patch com a solução do bug na versão do software onde o bug foi encontrado.
	Execução do software com o bug, seguindo os passos para reprodução do bug, e verificando que o bug não se manifesta
	Inspeção do código-fonte. Deve ser verificada a aderência às convenções de codificação do projeto e a outras políticas (por exemplo, cada patch deve vir com testes de unidade).
	Execução de testes de unidade (se houver). Deve se verificar que todos os testes passam.
	Bom, mas isso é a teoria. Quais atividades são executadas na prática, em projetos reais, antes de se marcar um bug como VERIFIED? Para responder a essa pergunta, analisei um total de 80 bugs, considerando os projetos Eclipse/EMF, Eclipse/Platform, Netbeans/versioncontrol e Netbeans/profiler. Eis alguns casos verificados nesses projetos:

	O reporter (ou outro usuário que também enfrenta o problema) verificou que, em uma build do produto que inclui a solução, o bug deixou de se manifestar. Aparentemente não há inspeção do código-fonte, e nem uma equipe de QA. Situação frequente no Netbeans. Pode ser um procedimento necessário quando os desenvolvedores não conseguem reproduzir o bug.
	A solução está disponível em um build que é divulgado no site do projeto. Esse critério é usado pelo projeto Eclipse/EMF e foi decidido em reunião. O projeto usa o status FIXED para bugs cuja solução está no CVS.
	Bugs que já foram resolvidos há muito tempo são marcados como verificados, por se entender que, se nenhuma problema ocorreu até então, isso significa que a solução é adequada.
	A mesma pessoa que resolve o bug o marca como VERIFIED logo depois. Aparentemente não existe verificação de fato nesse caso.
	O desenvolvedor que resolve o bug solicita que outro desenvolvedor verifique a solução. Comum no Eclipse/Platform.
	No bug 249436 do Eclipse/EMF, um patch é submetido por um desenvolvedor, mas outro desenvolvedor acaba reescrevendo o patch, fornecendo evidências de que o código-fonte foi inspecionado.
	No bug 269789 do Eclipse/EMF, há evidências da elaboração e da execução de testes de unidade.
	A análise sugere que o status VERIFIED significa coisas diferentes em diferentes projetos. A execução de uma versão corrigida do software parece ser o método predominante de verificação. Em alguns casos, o status VERIFIED não representa verificação, e sim a indicação de que a solução está disponível para o usuário final. Evidências de inspeção de código e execução de testes de unidade só foram encontradas no projeto Eclipse/Platform.	

\end{section}

\begin{section}{Conclusion}
\end{section}

\section*{Acknowledgment}

The first author is supported by FAPESB under grant BOL0119/2010.
